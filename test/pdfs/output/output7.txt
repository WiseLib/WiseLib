                                                                                                                                                   1




        Taylor Expansion Diagrams: A Canonical Representation for
                   Verification of Data Flow Designs
                                       Maciej Ciesielski1 , Priyank Kalla2 , Serkan Askar1
                                   1
                                       Department of Electrical and Computer Engineering
                                        University of Massachusetts, Amherst, MA-01003
                                   2
                                       Department of Electrical and Computer Engineering
                                         University of Utah, Salt Lake City, UT 84112

                             Accepted for publication in IEEE Transactions on Computers
                                                    TC-0118-0404
                                                    April 28, 2006

This work has been supported by a grant from the National Sci-               of the design to higher levels. The power of abstraction of TEDs
ence Foundation, CCR-0204146, and in part by the international               allows one to represent behavioral dataflow designs efficiently, with
NSF/CNRS/DAAD supplement grant, INT-0233206.                                 memory requirements several orders of magnitude smaller than those
   Abstract—                                                                 of other known representations.
   Taylor Expansion Diagram (TED) is a compact, word-                            TEDs are applicable to modeling, symbolic simulation and equiv-
level, canonical representation for data flow computations                   alence verification of dataflow and algorithm-dominant designs, such
that can be expressed as multi-variate polynomials. TEDs                     as digital signal processing for audio, video and multimedia appli-
are based on a decomposition scheme using Taylor series                      cations and embedded systems. Computations performed by those
expansion that allows to model word-level signals as alge-                   designs can often be modeled as polynomials and readily be repre-
braic symbols. This power of abstraction, combined with                      sented with TEDs. The test for functional equivalence is then per-
canonicity and compactness of TED, makes it applicable to                    formed by checking isomorphism of the resulting graphs. While appli-
equivalence verification of dataflow designs. The paper de-                  cation of TEDs is limited to those designs whose computations can be
scribes the theory of TEDs and proves their canonicity. It                   expressed as multi-variate polynomials, their use for algorithmic ver-
shows how to construct a TED from a HDL design specifi-                      ification is particularly appealing. Experimental results confirm the
cation and discusses application of TEDs in proving equiv-                   potential of TEDs for equivalence verification of dataflow oriented
alence of such designs. Experiments were performed with a                    designs at behavioral and algorithmic levels.
variety of designs to observe the potential and limitations of                   The paper is organized as follows. Section II reviews contemporary
TEDs for dataflow design verification. Application of TEDs                   canonic representations and discusses their limitations. A complete
to algorithmic and behavioral verification is demonstrated.                  theory of TED is described in Section III. The composition operations
                                                                             and analysis of their complexity are presented in Section IV, while
                                                                             Section V describes the construction of TEDs for RTL designs and
                           I. Introduction                                   discusses their limitations. Section VI describes the implementation
   Design verification is the process of ensuring the correctness of de-     of the TED package along with some experimental results. Finally,
signs described at different levels of abstraction during various stages     Section VII concludes the paper with comments and directions for
of the design process. Continuous increase in the size and complexity        future work.
of digital systems has made it essential to address verification issues
at early stages of the design cycle. Identification of errors early in the                     II. Review of Previous Work
design process can significantly expedite time-to-market and make the           In the realm of high-level design verification, the issue of abstrac-
design and verification process more efficient. To address this prob-        tion of symbolic, word-level computations have received a lot of atten-
lem, robust, automated verification tools that can handle designs at         tion. This is visible in theorem-proving techniques, automated deci-
higher levels of abstraction, such as at behavioral and algorithmic          sion procedures for Presburger arithmetic [9] [10], techniques using al-
levels, need to be developed.                                                gebraic manipulation [11], symbolic simulation [12], or in the decision
   Having matured over the years, formal design verification meth-           procedures that use “a combination of theories” [13] [14], etc. Term
ods, such as theorem proving, property and model checking, equiv-            re-writing systems, particularly those used for hardware verification
alence checking, etc., have found increasing application in industry.        [15] [16] [17], etc., also represent computations in high-level sym-
Canonic graph-based representations, such as Binary Decision Dia-            bolic forms. The above representations and verification techniques,
grams (BDDs) [1], Binary Moment Diagrams (BMDs) [2] and their                however, do not rely on canonical forms. For example, verification
variants (PHDDs [3], K*BMDs [4], etc.) play an important role in             techniques using term rewriting are based on rewrite rules that lead
the development of computer-aided verification tools. In particular,         to normal forms. Such forms may produce false negatives, which may
these representations have been be used to model RTL designs and             be difficult to analyze and resolve. In contrast, the TED representa-
prove their equivalence at the bit level. However, these representa-         tion proposed in this paper not only abstracts bit-vector arithmetic
tions are limited in their ability to represent algebraic computations       computations as polynomials, but also represents them canonically.
in abstract, higher-level, symbolic forms.                                      Various forms of high-level logics have been used to represent
   This motivated us to derive a new representation for high-level           and verify high-level design specifications. Such representations are
design descriptions, termed Taylor Expansion Diagrams (TEDs).                mostly based on quantifier free fragments of first order logic. The
This representation is particularly suited for modeling and supporting       works that deserve particular mention include: the logic of equal-
equivalence verification of designs specified at the behavioral level [5]    ity with uninterpreted functions (EUF) [18] and with memories
[6]. Similar to BDDs and BMDs, TED is a canonical, graph-based               (PEUFM) [19] [20], and the logic of counter arithmetic with lambda
representation. In contrast to BDDs and BMDs, TED is based on a              expressions and uninterpreted functions (CLU) [21]. To avoid expo-
non-binary decomposition principle, modeled along the Taylor’s series        nential explosion of BDDs, equivalence verification is generally per-
expansion [7], [8]. With this new data structure, word-level signals         formed by transforming high-level logic description of the design into
are represented as algebraic symbols, raising the level of abstraction       propositional logic formulas [21] [14] [19] and employing satisfiabil-
,                                                                                                                                                  2


ity tools [22] [23] for testing the validity of the formulas. While these   defined over words with large bit-width, as commonly encountered in
techniques have been successful in the verification of control logic and    many DSP applications, *BMD remains an expensive representation.
pipelined microprocessors, they have found limited application in the          K*BMD [4] attempts to make the BMD decomposition more effi-
verification of large data-path designs.                                    cient in terms of the graph size. This is done by admitting multiple
   Word-Level ATPG techniques [24] [25] [26] [27] [28] have also been       decomposition types, such as Davio, Shannon, etc., to be used in a sin-
used for RTL and behavioral verification. However, their applications       gle graph, and allowing both the multiplicative and additive weights
are generally geared toward simulation, functional vector generation        assigned to the graph edges. However, a set of restrictions imposed
or assertion property checking, but not so much toward high-level           on the edge weights to make it canonical makes such a graph difficult
equivalence verification of arithmetic datapaths.                           to construct.

A. Decision Diagram Based Representations                                   C. Symbolic Algebra Methods
   Reduced Ordered Binary Decision Diagrams (ROBDDs, or BDDs                   Many computations encountered in behavioral design specifica-
for short) [1], along with their efficient implementation as software       tions, can be represented in terms of polynomials. This includes
packages [29], are credited with significantly increasing the efficiency    digital signal and image processing designs, digital filter designs, and
of equivalence checking for logic designs. BDD represents a set of          many designs that employ complex transformations, such as DCT,
binary valued decisions in a rooted directed acyclic graph (DAG),           DFT, FFT, etc. Polynomial representations of discrete functions have
based on a recursive Shannon decomposition. This decomposition,             been explored in literature long before the advent of contemporary
combined with a set of reduction rules, makes the resulting diagram         canonical graph-based representations. Particularly, Taylor’s expan-
minimal and canonical for a given ordering of variables [1].                sion of Boolean functions has been studied in [43] [44]. However, these
   BDDs have found wide application in a number of verification prob-       works mostly targeted classical switching theory problems: logic min-
lems, including combinational equivalence checking [30], implicit state     imization, functional decomposition, fault detection, etc. The issue
enumeration [31], symbolic model checking [32] [33], etc. However,          of abstraction of bit-vectors and symbolic representation of compu-
as the designs have grown in size and complexity, the size-explosion        tations for high-level synthesis and formal verification was not their
problems of BDDs have limited their scope. Most BDD-based veri-             focus.
fication systems, such as SMV [33] and VIS [34], have been success-            Polynomial models of high-level design specifications have been
ful in verifying control-dominated applications. However, for designs       used recently in the context of behavioral synthesis for the purpose
containing large arithmetic data-path units, BDDs have not been             of component mapping [45], [46], [47]. A polynomial representation
very successful due to prohibitive memory requirements, especially          is created for each component (operator) from the library and the
for large multipliers.                                                      polynomials are matched by comparing their coefficients. However,
   Numerous attempts have been made to extend the capabili-                 storing and comparing large matrices of such coefficients is ineffi-
ties of verification engines to target arithmetic units. Majority of        cient for large multi-variate polynomials. The TED representation
these methods are based on generic Word Level Decision Diagrams             described in this paper can provide a more robust data structure for
(WLDDs), graph-based representations for functions with a Boolean           performing these tasks efficiently, due to its compact and canonical
domain and an integer range. Most of the WLDD representations               structure.
are based on a point-wise, or binary decomposition principle. Differ-          Several commercial symbolic algebra tools, such as Maple [48],
ent flavors of Boolean decomposition (Shannon, Davio, Reed-Muller,          Mathematica [49], and MatLab [50], use advanced symbolic algebra
etc.) are used to decompose functions w.r.t. their bit-level variables,     methods to perform efficient manipulation of mathematical expres-
leading to different Decision Diagrams. In addition to BDDs [1] and         sions. These tools have also been used for the purpose of polynomial
Partitioned BDDs [35], they include edge-valued BDDs (EVBDDs)               mapping, namely to perform simplification modulo polynomial [47].
[36], and functional decision diagrams (FDDs, KFDDs) [37] [38]. By          However, despite the unquestionable effectiveness and robustness of
extending BDDs to allow numeric leaf values point-wise decomposi-           these methods for classical mathematical applications, they are less
tion leads to different Multi-terminal BDDs, or MTBDDs [39], and            effective in modeling of large scale digital circuits and systems. We
Algebraic Decision Diagrams (ADDs) [40]. However, the decomposi-            believe that these methods can benefit from canonical representations
tion at each variable is still binary. As a result, a linear increase in    such as TED, in particular for component matching and equivalence
the size of input variables results, in the worst case, in an exponen-      checking.
tial increase in the size of decision diagrams. A thorough review of           It is interesting to note that symbolic algebra tools offered by
WLDDs can be found in [41].                                                 Mathematica and alike cannot unequivocally determine the equiv-
                                                                            alence of two polynomials. The equivalence is checked by subject-
B. Moment Diagram Based Representations                                     ing each polynomial to a series of expand operations and comparing
   Binary Moment Diagrams, BMDs, *BMDs [2], and their deriva-               the coefficients of the two polynomials ordered lexicographically. As
tives (PHDDs [42], K*BMD [4], etc.), depart from a point-wise de-           stated in the manual of Mathematica 5, Section 2.3.1, “there is no
composition and perform a decomposition of a linear function based          general way to find out whether an arbitrary pair of mathematical ex-
on its first two moments. BMD uses a modified Shannon’s ex-                 pressions are equal” [49]. Furthermore, Mathematica “cannot guar-
pansion, in which a binary variable is treated as a (0,1) integer:          antee that any finite sequence of transformations will take any two
f (x) = x · fx + x · fx = x · fx + (1 − x) · fx = fx + x · (fx − fx )       arbitrarily chosen expressions to a standard form.” (Mathematica 5,
where “·”, “+” and “-” denote algebraic multiplication, addition and        Section 2.62). In contrast, the TED data structure described in the
subtraction, respectively. The above decomposition is termed as mo-         sequel provides an important support for equivalence verification by
ment decomposition, where (fx − fx ) is the linear moment and fx the        offering a canonical representation for multi-variate polynomials.
constant moment. In this form, f can be viewed as a linear function
                                                                                             III. Taylor Expansion Diagrams
in its variables x, and (fx − fx ) as the partial derivative of f with
respect to x.                                                                  A known limitation of all decision and moment diagram repre-
   Binary moment diagrams provide a concise representation of               sentations is that word-level computations, such as A + B, require
integer-valued functions defined over bit vectors (words), X =              the decomposition of the function with respect to bit-level variables
    i
      2i xi , where each xi is a binary variable. The binary moment de-     A[k], B[k]. Such an expansion creates a large number of variables
composition is recursively applied to each variable xi . In such defined    in the respective diagram framework and requires excessive memory
BMD, multiplicative constants reside in the terminal nodes. The con-        and time to operate upon them. In order to efficiently represent and
stants can also be represented as multiplicative terms and assigned to      process the HDL description of a large design, it is desirable to treat
the edges of the graph, giving a rise to Multiplicative Binary Moment       the word-level variables as algebraic symbols, expanding them into
Diagram, or *BMD [2]. An example of such a diagram is depicted in           their bit-level components only when necessary.
the left part of Fig. 1. Several rules for manipulating edge weights           Consider the *BMD for A · B, shown in Fig. 1 (a), which depicts
are imposed on the graph to allow the graph to be canonical. For            the decomposition with respect to the bits of A and B. It would be
linear and multi-linear expressions *BMD representation is linear in        desirable to group the nodes corresponding to the individual bits of
the number of variables. However, the size of *BMD for X k , where          these variables to abstract the integer variables they represent, and
X is an n-bit vector, is O(nk ). Thus, for high-degree polynomials          use the abstracted variables directly in the design. Fig. 1 depicts the
,                                                                                                                                                                    3



                                b2                                                                                                f
                                                                   B[0:2]
                                        4b2 + 2b1 + b0 => B[0:2]
                       b1           4                                       TED: A*B                                  x v
              b0            2                                                                                                           x3 ...
                        1
                            a2                                                                                    1           x       x2 f‘"(0)/3!
                                        4a2 + 2a1 + a0 => A[0:2]        A[0:2]
                       a1        4                                                                          f(0) f’(0) f"(0)/2
                 a0         2
                                    *BMD: A*B
                       1                                                                             Fig. 2. A decomposition node in a TED.

             0                  1                                  0          1

Fig. 1. Abstraction of bit-level variables into algebraic symbols for                      Example: Figure 3 shows the construction of a TED for the alge-
    F = A · B.                                                                         braic expression F = (A+B)(A+2C) = A2 +A·(B+2·C+2·B·C). Let
                                                                                       the ordering of variables be A, B, C. The decomposition is performed
                                                                                       first with respect to variable A. The constant term of the Taylor ex-
                                                                                       pansion F (A = 0) = 2 · B · C. The linear term of the expansion gives
idea of such a symbolic abstraction of variables from their bit-level                  F (A = 0) = B +2·C; the quadratic term is 21 ·F (A = 0) = 21 ·2 = 1.
components.                                                                            This decomposition is depicted in Fig. 3 (a). Now the Taylor series
   In order to achieve the type of abstracted representation depicted                  expansion is applied recursively to the resulting terms with respect
above, one can rewrite the moment decomposition f = fx +x·(fx −fx )                    to variable B, as shown in Fig. 3(b), and subsequently with respect
                         ∂(f )                                                         to variable C. The resulting diagram is depicted in Fig. 3(c), and
as f = f (x = 0) + x · ∂x . This equation resembles a truncated
Taylor series expansion of the linear function f with respect to x. By                 its final reduced and normalized version (to be explained in Section
allowing x to take integer values, the binary moment decomposition                     III-B) is shown in Fig. 3(d). The function encoded by the TED can
can be generalized to a Taylor’s series expansion. This way one can                    be evaluated by adding all the paths from non-zero terminal nodes to
represent integer variables without expanding them into bits.                          the root, each path being a product of the variables in their respective
                                                                                       powers and the edge weights, resulting in F = A2 +AB +2AC +2BC.
A. The Taylor Series Expansion                                                             Using the terminology of computer algebra [51], TED employs
                                                                                       a sparse recursive representation, where a multivariate polynomial
   Let f (x) be a continuous, differentiable function defined over the
                                                                                       p(x1 , · · · , xn ) is represented as:
domain R of real variables. The Taylor series expansion of f w.r.t.
variable x at an initial point, x0 = 0, is represented as follows [8]:                                                            m

             ∞
                                                                                                      p(x1 , · · · , xn ) =           pi (x1 , · · · , xn−1 )xin   (2)
                      1                                    1                                                                  i=0
 f (x) =                 (x−x0 )k f k (x0 ) = f (0)+xf (0)+ x2 f (0)+.... (1)
                      k!                                   2
            k=0                                                                        The individual polynomials pi (x1 , · · · , xn−1 ) can be viewed as “coef-
                                                                                       ficients” of the leading variable xn at the decomposition level corre-
where f (x0 ), f (x0 ), etc., are first, second, and higher order deriva-              sponding to xn . By construction, the sparse form stores only non-zero
tives of f with respect to x, evaluated at x0 = 0. The Taylor series                   polynomials as the nodes of the TED.
expansion can be suitably adapted to represent computations over
integer and Boolean variables, as commonly encountered in HDL de-                      B. Reduction and Normalization
scriptions. Arithmetic functions and dataflow portions of those de-                       It is possible to further reduce the size of an ordered TED by a
signs, can be expressed as multi-variate polynomials of finite degree                  process of TED reduction and normalization. Analogous to BDDs
for which Taylor series is finite.                                                     and *BMDs, Taylor Expansion Diagrams can be reduced by remov-
   Let f (x, y, . . .) be a real differentiable function in variables                  ing redundant nodes and merging isomorphic subgraphs. In general,
{x, y, . . .}. Assume an algebra (R, ·, +) over real numbers R. Us-                    a node is redundant if it can be removed from the graph, and its
ing the Taylor series expansion with respect to a variable x, function                 incoming edges can be redirected to the nodes pointed to by the out-
f can be represented as: f (x, y, . . .) = f (x = 0, y, · · ·) + xf (x =               going edges of the node, without changing the function represented
0, y, · · ·) + 21 x2 f ”(x = 0, y, · · ·) + .... The derivatives of f evaluated at     by the diagram.
x = 0 are independent of variable x, and can be further decomposed                        Definition III.2: A TED node is redundant if all of its non-0
w.r.t. the remaining variables, one variable at a time. The result-                    edges are connected to terminal 0.
ing recursive decomposition can be represented by a decomposition                      If node v contains only a constant term (0-edge), the function com-
diagram, called the Taylor Expansion Diagram, or TED.                                  puted at that node does not depend on the variable var(v), associated
   Definition III.1: The Taylor Expansion Diagram, or TED,                             with the node. Moreover, if all the edges at node v point to the ter-
is a directed acyclic graph (Φ, V, E, T ), representing a multi-variate                minal node 0, the function computed at the node evaluates to zero.
polynomial expression Φ. V is the set of nodes, E is the set of directed               In both cases, the parent of node v is reconnected to the 0-child of v,
edges, and T is the set of terminal nodes in the graph. Every node                     as depicted in Fig. 4.
v ∈ V has an index var(v) which identifies the decomposing variable.
The function at node v is determined by the Taylor series expansion
at x = var(v) = 0, according to equation 1. The number of edges em-                                                x v
anating from node v is equal to the number of nonempty derivatives
of f (including f (0)) w.r.t. variable var(v). Each edge points to a
subgraph whose function evaluates to the respective derivative of the                                            y u                        y u
function with respect to var(v). Each subgraph is recursively defined
as TED w.r.t. the remaining variables. Terminal nodes evaluate to                                                             0
constants.
   Starting from the root, the decomposition is applied recursively                    Fig. 4. Removal of redundant node with only a constant term edge.
to the subsequent children nodes. The internal nodes are in one-
to-one correspondence with the successive derivatives of function f                       Identification and merging of isomorphic subgraphs in a TED are
w.r.t. variable x evaluated at x = 0. Figure 2 depicts one-level                       analogous to that of BDDs and *BMDs. Two TEDs are considered
decomposition of function f at variable x. The k-th derivative of a                    isomorphic if they match in both their structure and their attributes;
function rooted at node v with var(v) = x is referred to as a k-child                  i.e. if there is a one-to-one mapping between the vertex sets and the
                                                           1
of v; f (x=0) is a 0-child, f (x=0) is a 1-child, 2!         f (x=0) is a 2-child,     edge sets of the two graphs that preserve vertex adjacency, edge labels
etc. We shall also refer to the corresponding arcs as 0-edge (dotted),                 and terminal leaf values. By construction, two isomorphic TEDs
1-edge (solid), 2-edge (double), etc.                                                  represent the same function.
,                                                                                                                                                         4



                                     A                          A                                A                       A
                      F(A=0) = 2BC
                                                        B           B                    B           B           B           B
                              F’(A=0) = B + 2C
                                                                    2C                           C                       C
                                     1/2 F’’(A=0) = 1                                                                            2
                                                   1        0                 1              0           2   1       0                 1
                                         (a)                            (b)                          (c)                         (d)

     Fig. 3. Construction of a TED for F = (A + B)(A + 2C): (a)-(c) decomposition w.r.t. individual variables; (d) normalized TED



   In order to make the TED canonical, any redundancy in the graph                the Taylor’s theorem and the properties of reduced and normalized
must be eliminated and the graph must be reduced. The reduction                   TEDs, it can be shown that an ordered, reduced and normalized TED
process entails merging the isomorphic sub-graphs and removing re-                is canonical.
dundant nodes.                                                                       Theorem 2: For any multivariate polynomial f with integer coef-
   Definition III.3: A Taylor expansion diagram is reduced if it                  ficients, there is a unique (up to isomorphism) ordered, reduced and
contains no redundant nodes and has no distinct vertices v and v ,                normalized Taylor Expansion Diagram denoting f , and any other
such that the subgraphs rooted at v and v are isomorphic. In other                Taylor Expansion Diagram for f contains more vertices. In other
words, each node of the reduced TED must be unique.                               words, an ordered, reduced and normalized TED is minimal and
   It is possible to further reduce the graph by performing a procedure           canonical.
called normalization, similar to the one described for *BMDs [2]. The             Proof: The proof of this theorem follows directly the arguments used
normalization procedure starts by moving the numeric values from                  to prove the canonicity and minimality of BDDs [1] and *BMDs [2].
the non-zero terminal nodes to the terminal edges, where they are                 Uniqueness. First, a reduced TED has no trivial redundancies; the
assigned as edge weights. This is shown in Fig. 3(d) and Fig. 5(b). By            redundant nodes are eliminated by the reduce operation. Similarly, a
doing this, the terminal node holds constant 1. This operation applies            reduced TED does not contain any isomorphic subgraphs. Moreover,
to all terminal edges with terminal nodes holding values different than           after the normalization step, all common subexpressions are shared
1 or 0. As a result, only terminal nodes 1 and 0 are needed in the                by further application of the reduce operation. By virtue of the Tay-
graph. The weights at the terminal edges may by further propagated                lor’s Theorem all the nodes in an ordered, reduced and normalized
to the upper edges of the graph, depending on their relative values.              TED are unique and distinguished.
The TED normalization process that accomplishes this is defined as                Canonicity. We now show that the individual Taylor expansion
follows.                                                                          terms, evaluated recursively, are uniquely represented by the internal
   Definition III.4: A reduced, ordered TED representation is nor-                nodes of the TED. First, for polynomial functions the Taylor series
malized when:                                                                     expansion at a given point is finite and, according to the Taylor’s The-
• The weights assigned to the edges spanning out of a given node are              orem, the series is unique. Moreover, each term in the Taylor’s series
relatively prime.                                                                 corresponds to the successive derivatives of the function evaluated at
• Numeric value 0 appears only in the terminal nodes.                             that point. By definition, the derivative of a differentiable function
• The graph contains no more than two terminal nodes, one each                    evaluated at a particular point is also unique. Since the nodes in
for 0 and 1.                                                                      the TED correspond to the recursively computed derivatives, every
By ensuring that the weights assigned to the edges spanning out of                node in the diagram uniquely represents the function computed at
a node are relatively prime, the extraction of common subgraphs is                that node. Since every node in an ordered, reduced and normalized
enabled. Enforcing the rule that none of the edges be allowed zero                TED is distinguished and it uniquely represents a function, the Taylor
weight is required for the canonization of the diagram. When all the              Expansion Diagram is canonical.
edge weights have been propagated up to the edges, only the value 0                  Minimality. We now show that a reduced, ordered and normalized
and 1 can reside in the terminal nodes.                                           TED is also minimal. This can be proved by contradiction. Let G be
   The normalization of the TED representation is illustrated by an               a graph corresponding to a reduced, normalized and hence canonical
example in Fig. 5. First, as shown in Fig. 5(b), the constants (6,                TED representation of a function f . Assume there exists another
5) are moved from terminal nodes to terminal edges. These weights                 graph G , with the same variable order as in G, representing f that
are then propagated up along the linear edges to the edges rooted                 is smaller in size than G. This would imply that graph G could be
at nodes associated with variable B, see Fig. 5(c). At this point the             reduced to G by the application of reduce and normalize operations.
isomorphic subgraphs (B +C) are identified at the nodes of B and the              However, this is not possible as G is a reduced and normalized rep-
graph is subsequently reduced by merging the isomorphic subgraphs,                resentation and contains no redundancies. The sharing of identical
as shown in Fig. 5(d).                                                            terms across different decomposition levels in the graph G has been
   It can be shown that normalization operation can reduce the size               captured by the reduction operation. Thus G cannot have a repre-
of a TED exponentially. Conversely, transforming a normalized TED                 sentation for f with fewer nodes than G. Hence G is a minimal and
to a non-normalized TED can, in the worst-case, result in an expo-                canonical representation for f .                                      ✷
nential increase in the graph size. This result follows directly from
the concepts of normalization of BMDs to *BMDs [2].                               D. Complexity of Taylor Expansion Diagrams
C. Canonicity of Taylor Expansion Diagrams                                            Let us now analyze the worst-case size complexity of an ordered
   It now remains to be shown that an ordered, reduced and normal-                and reduced Taylor Expansion Diagram. For a polynomial function
ized Taylor Expansion Diagram is canonical; i.e. for a fixed ordering             of degree k, decomposition with respect to a variable can produce
of variables, any algebraic expression is represented by a unique re-             k+1 distinct Taylor expansion terms in the worst-case.
duced, ordered and normalized TED. First, we recall the following                     Theorem 3: Let f be a polynomial in n variables and maximum
Taylor’s Theorem, proved in [8].                                                  degree k. In the worst case, the ordered, reduced, normalized Taylor
   Theorem 1 (Taylor’s Theorem [8]) Let f (x) be a polynomial func-               Expansion Diagram for f requires O(k n−1 ) nodes and O(k n ) edges.
tion in the domain R, and let x = x0 be any point in R. There                     Proof: The top-level contains only one node, corresponding to the
exists one and only one unique Taylor’s series with center x0 that                first variable. Since its maximum degree is k, the number of distinct
represents f (x) according to the equation 1.                                     children nodes at the second level is bounded by k +1. Similarly, each
The above theorem states the uniqueness of the Taylor’s series rep-               of the nodes at this level produces up to k + 1 children nodes at the
resentation of a function, evaluated at a particular point (in our case           next level, giving a rise to (k + 1)2 nodes, and so on. In the worst case
at x = 0). This is a direct consequence of the fact that the succes-              the number of children increases in geometric progression, with the
sive derivatives of a function evaluated at a point are unique. Using             level i containing up to (k + 1)i−1 nodes. For an n-variable function,
,                                                                                                                                                                                                         5



                                                           A2 (B+C)+5A(B+C)+6(B+C)                                                                              (A2 +5A+6)(B+C)
                                                                                                                                                                            A
                                               A                                                          A                                         A
                                                                                                                                                                           6 5       1
                                                                                                                                                   6
                                                                                                                                                        5
                                       B                                                    B                                              B                               B
                                                                                                6                         5
                                       C                                                C                                                  C                                         C
                                                                                                    6                5

                                           6   0           5         0       1                  1             0      1        0   1            1    0       1   0   1          1     0

                                                           (a)                                                     (b)                                  (c)                    (d)
                                                               Fig. 5. Normalization of the TED for F = (A2 + 5A + 6)(B + C)


there will be n-1 such levels, with the n-th level containing just two                                                               In general, at any level l, associated with variable xn−l , the ex-
terminal nodes, 1 and 0. Hence the total number of internal nodes in                                                              pansion of terms Wn−l 2   and Wn−l will create exactly two different
                     n−1            (k+1)n −1
the graph is N =     i=0
                         (k +1)i =      k
                                              . The number of edges E                                                                                                      2
                                                                                                                                  non-constant terms, one representing Wn−l−1    and the other Wn−l−1 ;
                                                                 n                          (k+1)n+1 −1                           plus a constant term 2   n−l . The term Wn−l−l will be shared, with
can be similarly computed as E =        i=1
                                            (k + 1)i =       k
                                                                     − 1,                                                                                                  2
since there may be up to (k + 1)n terminal edges leading to the 0                                                                 different multiplicative constants, by Wn−l  and Wn−l .
and 1 nodes. Thus, in the worst-case, the total number of internal                                                                   This reasoning can be readily generalized to arbitrary integer de-
nodes required to represent an n-variable polynomial with degree k                                                                gree k; at each level there will always be exactly k different non-
is O(k n−1 ) and the number of edges is O(k n ).                       ✷                                                          constant terms. Since on the top variable (xn−1 ) level there is only
                                                                                                                                  one node (the root), and there are exactly k non-constant nodes at
    One should keep in mind, however, that the TED variables rep-
                                                                                                                                  each of the remaining (n − 1) levels, the total number of nodes is
resent symbolic, word-level signals, and the number of such signals
                                                                                                                                  equal to k(n − 1) + 1.                                              ✷
in the design is significantly smaller than the number of bits in the
bit-level representation. Subsequently, even an exponential size of the                                                           E. Limitations of Taylor Expansion Diagram Representation
polynomial with a relatively small number of such variables may be
acceptable. Moreover, for many practical designs the complexity is                                                                   It should be obvious from the definition of TED that it can only
not exponential.                                                                                                                  represent those functions that have finite Taylor expansion, and in
    Finally, let us consider the TED representation for functions with                                                            particular multi-variate polynomials with finite integer degrees. For
                                               n−1 i                                                                              polynomials of finite integer degree k ≥ 1, successive differentiation
variables encoded as n-bit vectors, X =        i=0
                                                    2 xi . For linear ex-                                                         of the function ultimately leads to zero, resulting in a finite number of
pressions, the space complexity of TED is linear in the number of                                                                 terms. However, those functions that have infinite Taylor series (such
bits n, the same as *BMD. For polynomials of degree k ≥ 2, such as                                                                as ax , where a is a constant) cannot be represented with a finite TED
X 2 , etc., the size of *BMD representation grows polynomially with                                                               graph.
the number of bits, as O(nk ). For K*BMD the representation also                                                                     Another natural limitation of TEDs is that they cannot represent
becomes nonlinear, with complexity O(nk−1 ), for polynomials of de-                                                               relational operators (such as comparators, A ≥ B, A == B, etc.)
gree k ≥ 3. However, for ordered, reduced and normalized TEDs, the                                                                in symbolic form. This is because Taylor series expansion is defined
graph remains linear in the number of bits, namely O(n · k), for any                                                              for functions and not for relations. Relations are characterized by
degree k, as stated in the following theorem.                                                                                     discontinuities over their domain and are not differentiable. In order
    Theorem 4: Consider variable X encoded as an n-bit vector, X =                                                                to use TEDs to represent relational operators, often encountered in
    n−1 i
    i=0
         2 xi . The number of internal TED nodes required to represent                                                            RTL descriptions, the expansion of word-level variables and bit vec-
   k
X in terms of bits xi , is k(n − 1) + 1.                                                                                          tors into their bit-level components is required. Finally, TEDs cannot
    Proof: We shall first illustrate it for the quadratic case k = 2.                                                             represent modular arithmetic. This issue will be discussed in Section
                                                             n−1 i                                                                V-C in the context of RTL verification.
Let Wn be an n-bit representation of X: X = Wn =             i=0
                                                                  2 xi =
                                                                         n−2                                                          IV. Composition Operations for Taylor Expansion Diagrams
2(n−1) xn−1 + Wn−1 where Wn−1 =        i=0
                                           2i xi is the part of X
containing the lower (n-1) bits. With that, Wn2 = (2n−1 xn−1 +                                                                        Taylor Expansion Diagrams can be composed to compute complex
Wn−1 )2 = 22(n−1) x2n−1 + 2n xn−1 Wn−1 + Wn−1  2   . Furthermore,                                                                 expressions from simpler ones. This section describes general com-
let Wn−1 = (2  n−2                       2
                   xn−2 + Wn−2 ), and Wn−1 = (22(n−2) x2n−2 +                                                                     position rules to compute a new TED as an algebraic sum (+) or
                     2                                                                                                            product (·) of two TEDs. The general composition process for TEDs
2n−1 xn−2 Wn−2 + Wn−2   ).                                                                                                        is similar to that of the apply operator for BDD’s [1], in the sense that
   Notice that the constant term (0-edge) of Wn−1 w.r.to variable                                                                 the operations are recursively applied on respective graphs. However,
xn−2 contains the term Wn−2 , while the linear term (1-edge) of Wn−12
                                                                                                                                  the composition rules for TEDs are specific to the rules of the algebra
contains 2n−1 Wn−2 . This means that the term Wn−2 can be shared                                                                  (R, ·, +).
at this decomposition level by two different parents.As a result, there                                                               Starting from the roots of the two TEDs, the TED of the result is
are exactly two non-constant terms, Wn−2 and Wn−2   2   at this level.                                                            constructed by recursively constructing all the non-zero terms from
                                                                                                                                  the two functions, and combining them, according to a given opera-
                                                                                                                                  tion, to form the diagram for the new function. To ensure that the
    2 2(n−1)    Wn
                   2            xn−1                             2 2(n−1)        Wn
                                                                                   2            xn−1                              newly generated nodes are unique and minimal, the reduce operator
                                                                                                                                  is applied to remove any redundancies in the graph.
     1                                                            1                         n
                        2
                            n                                                           2                                             Let u and v be two nodes to be composed, resulting in a new node
                                                                                                                                  q. Let var(u) = x and var(v) = y denote the decomposing variables
     Wn−1
         2
                       Wn−1        xn−2            2   2(n−2)
                                                                     Wn−1
                                                                         2
                                                                                       Wn−1               x n−2                   associated with the two nodes. The top node q of the resulting TED
                                                       1                     2
                                                                                 n−1
                                                                                                        n−2
                                                                                                                                  is associated with the variable with the higher order, i.e., var(q) = x,
                                                                                                    2                             if x ≥ y, and var(q) = y otherwise. Let f, g be two functions rooted
                                                                2
                                                           Wn−2              Wn−2                   1             x n−3           at nodes u, v, respectively, and h be a function rooted at the new
                                                                                                                                  node q.
                                                                                                                                      For the purpose of illustration, we describe the operations on lin-
               Fig. 6. Construction of TED for X 2 with n bits                                                                    ear expressions, but the analysis is equally applicable to polynomials
,                                                                                                                                                                                                           6


of arbitrary degree. In constructing these basic operators, we must                                                     to the children proceeds until the weights reach the terminal nodes.
consider several cases:                                                                                                 The numeric values are updated only in the terminal nodes. Every
1. Both nodes u, v are terminal nodes. In this case a new terminal                                                      time a new node is created, the reduce and normalize operations
node q is created as val(q) = val(u) + val(v) for the add operation,                                                    are required to be performed in order to remove any redundancies
and as val(q) = val(u) · val(v) for the mult operation.                                                                 from the graph and generate a minimal and canonical representation.
2. At least one of the nodes is non-terminal. In this case the TED                                                         We now analyze the computational complexity of the basic TED
construction proceeds according to the variable order. Two cases                                                        operations described above. Let |f | and |g| be the size, expressed in
need to be considered here: (a) when the top nodes u, v have the                                                        the number of nodes, of the two TEDs, f and g, respectively. The
same index, and (b) when they have different indices. The detailed                                                      number of recursive calls made to add is bounded by ≤ (|f | · |g|). The
analysis of both cases is given in [6]. Here we show the multiplication                                                 mult operation has higher complexity than add. The worst case for
of two diagrams rooted at variables u and v with the same index.                                                        the multiply operation would occur when each node in f is multiplied
      h(x) = f (x) · g(x) = (f (0) + xf (0)) · (g(0) + xg (0))                                                    (3)   by each node in g, resulting in (|f |·|g|) recursive mult calls. However,
                                                                                                                        each multiply operation further relies on (|f | · |g|) recursive calls to
     = [f (0)g(0)] + x[f (0)g (0) + f (0)g(0)] + x2 [f (0)g (0)].                                                       the add operation, in the worst case (see Fig. 8).
                                                                                                                           In order to derive an absolute worst-case upper bound for the com-
In this case, the 0-child of q is obtained by pairing the 0-children                                                    position operations, we have to consider the case where edge-weights
of u, v. Its 1-child is created as a sum of two cross products of 0-                                                    have to be propagated all the way down to terminal nodes. In such
and 1-children, thus requiring an additional add operation. Also,                                                       cases, non-normalized TEDs are dynamically created from their nor-
an additional 2-child (representing the quadratic term) is created by                                                   malized counterparts. As discussed in Section III-B, non-normalized
pairing the 1-children of u, v.                                                                                         TEDs can be exponentially more complex than normalized TEDs.
                                                                                                                        This may result in an exponential worst-case complexity of the com-
                                                                              x   u*v                                   position operations. However, it should be noted that the number
             x       u                      x   v                                                 x2
                                   *                         =            1             x
                                                                                                                        of calls to the mult operation can be efficiently reduced by using a
                                                                                                                        computed table to store the results, as is done in the recent implemen-
                                                                                                        u1*v1
                                                                                                                        tation. A detailed analysis of the complexity of basic TED operations
      u0                 u1            v0             v1          u0*v0           u0*v1+u1*v0                           is presented in [52]. It should be noted that the multiplication of two
                                                                                                                        multi-variate polynomials has been shown to be exponential. For in-
 Fig. 7. Multiplicative composition for nodes with same variables.                                                      stance, time complexity of Karatsuba algorithm for multiplying two
                                                                                                                        n-variate polynomials with maximum degree d is O((d + 1)n log2 3 )
Figure 8 illustrates the application of the add and mult procedures                                                     [51].
to two TEDs. As shown in the figure, the root nodes of the two                                                             At the first glance, time complexity for TED construction appears
TEDs have the same variable index. The mult operation requires the                                                      to be prohibitive. However, we observed that for dataflow computa-
following steps: (i) performing the multiplication of their respective                                                  tions specified at sufficiently high level (see Section VI) the composi-
constant (0-) and linear (1-) children nodes; and (ii) generating the                                                   tion operations do not exhibit exponential complexity. The number
sum of the cross-products of their 0- and 1-children. On the other                                                      of symbolic variables is orders of magnitude smaller than that of
hand, the two TEDs corresponding to the resulting cross-product,                                                        Boolean variables present in the *BMD and BDD representations.
as highlighted in the figure, have different variable indices for their                                                 Exponential complexity can be observed in cases when the Boolean
root nodes. In this case, the node with the lower index corresponding                                                   variables start dominating in the design, in which case the behavior
to variable C is added to the 0-child of the node corresponding to                                                      of TED starts approaching that of a *BMD.
variable B.                                                                                                                      V. Design Modeling and Verification with TEDs
                                                                          A       4,6                                      Using the operations described in the previous section, Taylor Ex-
      A+B                      A + 2C                                                                                   pansion Diagrams can be constructed to represent various compu-
                                                                                                                        tations over symbolic variables in a compact, canonical form. The
     A 4                      A 6
                                                =         B 3,5                                                         compositional operators add and mult can be used to compute any

B 3
                     *                                                                      +
                                                                                                  3,1
                                                                                                        B
                                                                                                                        combination of arithmetic functions by operating directly on their
                                                                                                                        TEDs. However, the representation of Boolean logic, often present
                         C 5
                                                C   0,5             1,5               1,5 C                             in the RTL designs, requires special attention since the output of a
                                                                                                                        logic block must evaluate to Boolean rather than to an integer value.
 0               1       0         2    1
                                                0,0    0,2    1,0     1,2         1,0   1,2       0,1     1,1     1,1   A. Representing Boolean Logic
                                                                                                                           We now define TED operators for Boolean logic, or, and, and xor,
         (A+B)(A+2C)                                                                                                    where both the range and domain are Boolean. Figure 9 shows TED
                                                                                                                        representations for these basic Boolean operators. In the diagrams,
             A                                                                                                          x and y are Boolean variables represented by binary variables, and
                                                                                                   B    8,7             + and · represent algebraic operators of add and mult, respectively.
                                                                          B 8
     B                   B                             C 7                              =                               The resulting functions are 0,1 integer functions. These diagrams are
                                                                  +                         C     0,7                   structurally identical to their *BMD counterparts [53] [2].
             C
                         2                                   2
                                                       0                  0       1         0,0     0,2       1                                x                      x                     x
         0                     1
                                                                                                                             x
                                                                                                                                                   y              y        y            y         y
             Fig. 8. Example of mult composition: (A+B)(A+2C).
                                                                                                                                  −1                                           −1                     −2

   It should be noted that the add and mult procedures described                                                             1                         1                   1                    1
                                                                                                                                           0                  0                     0
above will initially produce non-normalized TEDs, with numeric val-
ues residing only in the terminal nodes, requiring further normaliza-                                                       NOT                AND                    OR                    XOR
tion. When these operations are performed on normalized TEDs,
with weights assigned to the edges, then the following modification                                                     Fig. 9. TED representation for Boolean operators: a) not: x =
is required: when the variable indices of the root nodes of f and g                                                         (1 − x); b) and: x ∧ y = x · y; c) or: x ∨ y = x + y − xy; d) xor:
are different, the edge weights have to be propagated down to the                                                           x ⊕ y = x + y − 2xy.
children nodes recursively. Downward propagation of edge weights
results in the dynamic update of the edge weights of the children                                                          Similarly one can derive other operators which rely on Boolean
nodes. In each recursion step, this propagation of edge weights down                                                    variables as one of their inputs, with other inputs being word-level.
,                                                                                                                                                     7


One such example is the multiplexer, mux(c, X, Y ) = c·X +(1−c)·Y ,            represent modular arithmetic. An attempt to fix this problem was
where c is a binary control signal, and X and Y are word-level inputs.         proposed in [54], by modeling the discrete functions as finite, word-
   In general, TED, which represents an integer-valued function, will          level polynomials in Galois Field (GF). The resulting polynomials,
also correctly model designs with arithmetic and Boolean functions.            however, tend to be of much higher degree than the original function,
Note that the add (+) function will always create correct integer              with the degree depending on the signal bit-width, making the rep-
result over Boolean and integer domains, because Boolean variables             resentation less efficient for practical applications. This is the case
are treated as binary (0,1), a special case of integer. However the            where TEDs can exhibit space explosion similar to that encountered
mult (·) function may create powers of Boolean variables, xk , which           in BDDs and BMDs.
should be reduced to x. A minor modification of TED is done to                    Despite these limitation, TEDs can be successfully used for verify-
account for this effect so that the Boolean nature of variable x can be        ing equivalence of high-level, behavioral and algorithmic descriptions.
maintained in the representation. Such modified Taylor Expansion               Such algorithmic descriptions typically do not exhibit signal splits,
Diagrams are also canonical.                                                   hence resulting in polynomial functions over word-level input signals.
B. Verification of RTL and Behavioral Designs                                           VI. Implementation and Experimental Results
   TED construction for an RTL design starts with building trivial                We have implemented a prototype version of TED software for
TEDs for primary inputs. Partial expansion of the word-level input             behavioral HDL designs using as a front end a popular high-level
signals is often necessary when one or more bits from any of the               synthesis system GAUT [55]. This system was selected due to its
input signals fan out to other parts of the design. This is the case in        commercial quality, robustness, and its open architecture. The input
the designs shown in Fig. 10 (a) and (b), where bits ak = A[k] and             to the system is behavioral VHDL or C description of the design.
bk = B[k] are derived from word-level variables A and B. In this case,         The design is parsed and the extracted data flow is automatically
the word-level variables must be decomposed into several word-level            transformed into canonical TED representation.
variables with shorter bit-widths. In our case, A = 2(k+1) Ahi +2k ak +           The core computational platform of the TED package consists of
Alo and B = 2(k+1) Bhi + 2k bk + Blo , where Ahi = A[n − 1:k+1],               a manager that performs the construction and manipulation of the
ak = A[k], and Alo = A[k-1:0]; and similarly for variable B. Variables         graph. It provides routines to uniquely store and manipulate the
Ahi , ak , Alo , Bhi , bk , Blo form the abstracted primary inputs of the      nodes, edges and terminal values, in order to keep the diagrams
system. The basic TEDs are readily generated for these abstracted              canonical. To support canonicity, the nodes are stored in a hash
inputs from their respective bases (Ahi , ak , Alo ), and (Bhi , bk , Blo ).   table, implemented as unique table, similar to that of the CUDD
   Once all the abstracted primary inputs are represented by their             package [29],[56]. The table contains a key for each vertex of the
TEDs, Taylor Expansion Diagrams can be constructed for all the                 TED, computed from the node index and the attributes of its chil-
components of the design. TEDs for the primary outputs are then                dren and the edge weights. As a result, equivalence test between two
generated by systematically composing the constituent TEDs in the              TEDs reduces to a simple scalar test between the identifiers of the
topological order, from the primary inputs to the primary outputs.             corresponding vertices.
For example, to compute A + B in Fig. 10 (a) and (b), the add                     Variable ordering. As shown in this paper, TEDs are a canon-
operator is applied to functions A and B (each represented in terms            ical representation subject to the imposition of a total ordering on
of their abstracted components). The subtract operation, A − B, is             the variables. Therefore it is desirable to search for a variable order
computed by first multiplying B with a constant −1 and adding the              that would minimize the size of TEDs. We have recently developed
result to the TED of A. The multipliers are constructed from their             a dynamic variable ordering for TEDs based on local swapping of
respective inputs using the mult operator, and so on. To generate a            adjacent variables in the diagram, similar to those employed in BDD
TED for the output of the multiplexers, the Boolean functions s1 and           ordering [57], [58]. It has been shown that, similarly to BDDs, local
s2 first need to be constructed as TEDs. Function s1 is computed               swapping of adjacent variables does not affect the structure of the
by transforming the single-bit comparator ak > bk into a Boolean               diagram outside of the swapping area. We are currently experiment-
function and expressed as an algebraic equation, s1 = ak ∧ bk =                ing with different static ordering heuristics, including the ordering
ak · (1 − bk ), as described in Section V-A. Similarly, s2 = ak ∨ bk           of variables that correspond to constant coefficients. Due to initial
is computed as s2 = 1 − ak · (1 − bk ) and represented as a TED.               nature of these heuristics, in our initial experiments we have used the
Finally, the TEDs for the primary outputs are generated using the              default (topological) order in which the signals appear in the design
mux operator with the respective inputs. As a result of such a series          specification.
of composition operations, the outputs of the TED represent multi-
variate polynomials of the primary inputs of the design.                       A. Experimental Setup
   After having constructed the respective ordered, reduced, and nor-
malized Taylor Expansion Diagram for each design, the test for func-              Several experiments were performed using our prototype software
tional equivalence is performed by checking for isomorphism of the             on a number of dataflow designs described in behavioral VHDL. The
resulting graphs. If the corresponding diagrams are isomorphic, they           designs range from simple algebraic (polynomial) computations to
represent equivalent functions. Fig. 10(c) shows the isomorphic TED            those encountered in signal and image processing algorithms. Sim-
for the two designs, demonstrating that they are indeed equivalent. In         ple RTL designs with Boolean-algebraic interface were also tested.
fact, the generation of the TEDs for the two designs under verification        We wish to emphasize that the goal of these experiments was to
takes place in the same TED manager; when the two functions are                demonstrate, as a proof of concept, the application of TED to high-
equivalent, both top functions point to the same root of the common            level dataflow design representation and verification, and in particular
TED.                                                                           to functional equivalence checking of behavioral HDL specifications,
                                                                               rather than to develop a complete equivalence verification system.
C. Limitations of TEDs in RTL Verification                                        Our experimental setup is as follows. The design described in be-
   The proposed TED representation naturally applies to functions              havioral VHDL or C is parsed by a high-level synthesis system GAUT
that can be modeled as finite polynomials. However, the efficiency of          [55]. The extracted data flow is then automatically translated into a
TED relies on its ability to encode the design in terms of its word-level      canonical TED representation using our software. Statistics related
symbolic inputs, rather than bit-level signals. This is the case with          to graph size and composition time are reported. We have compared
the simple RTL designs shown in Figure 10, where all input variables           TEDs against *BMDs to demonstrate the power of abstraction of
and internal signals have simple, low-degree polynomial representa-            TED representation. For this purpose, each design was synthesized
tion. The abstracted word-level inputs of these designs are created            into a structural netlist from which *BMDs were constructed. In
by partial bit selection (ak , bk ) at the primary inputs, and a poly-         most cases BDDs could not be constructed due to their prohibitive
nomial function can be constructed for its outputs. However, if any            size, and they are not reported. Experiments confirm that word-size
of the internal or output signals is partitioned into sub-vectors, such        abstraction by TEDs results in much smaller graph size and compu-
sub-vectors cannot be represented as polynomials in terms of the sym-          tation times as compared to *BMDs.
bolic, word-level input variables, but depend on the individual bits
                                                                               B. Verification of High-level Transformations
of the inputs. The presence of such signal splits creates a fundamen-
tal problem for the polynomial representations, and TEDs cannot                   During the process of architectural synthesis, the initial HDL de-
be used efficiently in those cases. For similar reasons TED cannot             scription often proceeds through a series of high-level transformations.
,                                                                                                                                                                                         8


                      B
                                 +
                                                                                                                                             F1
                                                                          F1
                      A                           *              1
                                                                 0                                                                           D                  D


                                 −                    D
                                                               s1
                                                                                                                                             -1

                                                                                                                                   aK.1           aK.2          aK
                               ak
                                      ak > bk                                                                                     bK.1                   bK.2   bK
                                bk                                                                                                 -1
                                                 (a)                                                                        Ahi                                 Ahi


                      A
                                                                                                                       -1


                                  *               −              0
                                                                 1
                                                                          F2                               Bhi                          32                      Bhi

                                                                                                      -1                                                  -1
                      B
                                  *                   D
                                                               s2                       -1
                                                                                              Alo.1

                                                                                                           256
                                                                                                                  32         256        Alo.2                   Alo


                                      ak
                                                                                    Blo.1             16         Blo.2                  8                       Blo


                                      bk                                                -64

                                                 (b)                                                                   T1


                                                                                                                              (c)
Fig. 10. RTL verification using canonical TED representation: (a), (b) Functionally equivalent RTL modules; (c) The isomorphic TED for
     the two designs.


For example, computation AC+BC can be transformed into an equiv-               estimation architecture [59]. Each processing element can perform
alent one, (A + B)C, which better utilizes the hardware resources.             two types of computations on a pair of 8-bit vectors, Ai , Bi , namely
TEDs are ideally suited to verify the correctness of such transfor-            (Ai − Bj ) or (A2i − Bj2 ), and the final result of all PEs is then added
mations by proving equivalence of the two expressions, regardless of           together. The size of the array was varied from 4 × 4 to 16 × 16, and
the word size of the input/output signals. We performed numerous               the TED for the final result was constructed for each configuration.
experiments to verify the equivalence of such algebraic expressions.              When the PEs are configured to perform subtraction (Ai − Bj ),
Results indicate that both time and memory usage required by TEDs              both TEDs and *BMDs can be constructed for the design. However,
is orders of magnitude smaller as compared to *BMDs. For example,              when the PEs are configured to compute A2i − Bj2 , the size of *BMDs
the expression (A + B)(C + D), where A, B, C, D are n-bit vectors,             grows quadratically. As a result, we were unable to construct *BMDs
has a TED representation containing just 4 internal nodes, regardless          for the 16 × 16 array of 8-bit processors. In contrast, the TEDs were
of the word size. The size of *BMD for this expression varies from             constructed easily for all the cases. The results are shown in Table
418 nodes for the 8-bit vectors, to 2,808 nodes for 32-bit variables.          II. Note that we were unable to construct the BDDs for any size n
BDD graphs could not be constructed for more than 15 bits.                     of the array for the quadratic computation.
C. RTL Verification
                                                                                                                   TABLE II
   As mentioned earlier, TEDs offer the flexibility of representing de-
signs containing both arithmetic operators and Boolean logic. We                                            PE computation: (A2i − Bj2 ).
used the generic designs of Figure 10 and performed a set of experi-
ments to observe the efficiency of TED representation under varying                 Array size                      *BMD                                                     TED
size of Boolean logic. The size of the algebraic signals A, B was kept               (n × n)                   Size     CPU time                                      Size    CPU time
constant at 32 bits, while the word size of the comparator (or the                    4× 4                     123         3s                                          10       1.2 s
equivalent Boolean logic) was varied from 1 to 20. As the size of                     6× 6                     986        3.4 s                                        14       1.5 s
Boolean logic present in the design increases, the number of bits ex-                 8× 8                    6842        112 s                                        18       1.6 s
tracted from A, B also increases (the figure shows it for single bits).              16× 16                out of mem       -                                          34       8.8 s
Table I gives the results obtained with TED and compares them to
those of *BMDs. Note that, as the size of Boolean logic increases,
TED size converges to that of *BMD. This is to be expected as
*BMDs can be considered as a special (Boolean) case of TEDs.                   E. DSP Computations

                           TABLE I                                                 One of the most suitable applications for TED representation are
                                                                               algorithmic descriptions of dataflow computations, such as digital sig-
                 Size of TED vs. Boolean logic                                 nal and image processing algorithms. For this reason, we have exper-
         bits          *BMD                       TED                          imented with the designs that implement various DSP algorithms.
         (k)      Size    CPU time           Size     CPU                          Table III presents some data related to the complexity of the TEDs
           4      4620      107 s            194      44 s                     constructed for these designs. The first column in the Table describes
           8      15K        87 s            998      74 s                     the computation implemented by the design. These include: F IR
                                                                               and IIR filters, fast Fourier transform (F F T ), elliptical wave filter
          12      19K        93 s            999      92 s
                                                                               (Elliptic), least mean square computation (LM S128), discrete cosine
          16     23.9K      249 s            4454     104 s
                                                                               transform (DCT ), matrix product computation (P rodM at), Kalman
          18    timeout    >12 hrs          12.8K    29 min
                                                                               filter (Kalman), etc. Most of these designs perform algebraic compu-
          20    timeout    >12 hrs         timeout  >12 hrs                    tations by operating on vectors of data, which can be of arbitrary size.
                                                                               The next column gives the number of inputs for each design. While
                                                                               each input is a 16-bit vector, TED represents them as word-level
                                                                               symbolic variable. Similarly, the next column depicts the number of
D. Array Processing                                                            16-bit outputs. The remaining columns of the table show: BMD size
   An experiment was also performed to analyze the capability of               (number of nodes), CPU time required to construct the BMD for the
TEDs to represent computations performed by an array of proces-                16-bit output words, TED size (number of nodes) required to repre-
sors. The design that was analyzed is an n × n array of configurable           sent the entire design; CPU times required to generate TED diagrams
Processing Elements (PE), which is a part of a low power motion                does not account for the parsing time of the GAUT front end.
,                                                                                                                                                                                                  9


                                                                                                                   TABLE III
                                                                                                         Signal Processing Applications
                                                            Design                No. of             No. of     *BMD size      BMD CPU        TED size     TED CPU
                                                                                  inputs            outputs       (nodes)        time (s)      (nodes)      time (s)
                                                     Dup-real                       3x16               1x16            92             10          5            1
                                                           IIR                      5x16               1x16           162             13          7            1
                                                        FIR16                      16x16               1x16           450             25         18            1
                                                          FFT                      10x16               8x16           995             31         29            1
                                                       Elliptic                     8x16               8x16           922             19         47            1
                                                      LMS128                       50x16               1x16          8194            128         52            1
                                                         DCT                       32x16              16x16          2562             77         82            1
                                                     ProdMat                       32x16              16x16          2786             51         89            1
                                                      Kalman                       77x16               4x16          4866            109         98            1




   Fig. 11 depicts a multiple-output TED for the elliptical wave filter                                                     it can be shown that TEDs can represent polynomial functions over
(design elliptic), where each root node corresponds to an output of                                                         an arbitrary field. The only modification required is that the weights
the design.                                                                                                                 on the graph edges be elements of the field, and that the composition
                                                                                                                            (mult and add) be performed with the respective operators of the
F. Algorithmic Verification                                                                                                 field. Subsequently, TEDs can also be used to represent computations
   In this final set of experiments we demonstrate the natural capa-                                                        in Galois field [54].
bility of Taylor Expansion Diagrams to verify equivalence of designs
described at the algorithmic level. Consider two dataflow designs                                                                           VII. Conclusions and Future Work
computing convolution of two real vectors, A(i), B(i), i = 0, . . . N − 1,
                                                                                                                                This paper has presented a compact, canonical, graph-based rep-
shown in Fig. 12. The design in Fig. 12(a) computes FFT of each
                                                                                                                            resentation, called Taylor Expansion Diagram (TED). It has been
vector, computes product of the FFT results, and performs the in-
                                                                                                                            shown that, for a fixed ordering of variables, TED is a canonical
verse FFT operation, producing output IF F T . The operation shown
                                                                                                                            representation that can be used to verify equivalence of arithmetic
in Fig. 12(b) computes convolution directly from the two inputs,
           N −1                                                                                                             computations in dataflow designs. The power of abstraction of TEDs
C(i) =     k=0
                 A(k) · B(i − k). TED was used to represent these two                                                       makes them particularly applicable to dataflow designs specified at
computations for N = 4 and to prove that they are indeed equivalent.                                                        the behavioral and algorithmic level. The theory of TEDs has been
Fig. 13 depicts the TED for vector C of the convolution operation,                                                          presented, and the various operations on TEDs described that make
isomorphic with the vector IF F T . All graphs are automatically gen-                                                       the graph minimal and canonical. Size complexity of the representa-
erated by our TED-based verification software.                                                                              tion and time complexity of its composition operations has also been
                                                                                                                            analyzed and compared to other contemporary representations. It
A0                                                                                                                          has been shown how TEDs can be constructed for behavioral and
A1                                                                               A0                                  C0     some RTL design descriptions.
         FFT(A)
A2                  x    FAB0
                                                                  IFFT0          A1
                                                                                                                                An initial implementation of a TED package and experimental re-
                                       InvFFT(FAB)




                                                                                 A2
A3                  x    FAB1
                                                                  IFFT1          A3
                                                                                                                     C1     sults have been described. Experiments were conducted over a num-
                                                                                                    Conv(A,B)
B0                  x    FAB2
                                                                  IFFT2                                                     ber of designs to observe the power and limitations of the TED rep-
                                                                                 B0                                  C2
B1
         FFT(B)
                    x    FAB3
                                                                  IFFT3          B1
                                                                                                                            resentation. The experiments demonstrate the applicability of TED
B2                                                                               B2                                         representation to verification of behavioral and algorithmic designs.
                                                                                                                     C3
B3                                                                               B3                                         Of particular promise is the use of TEDs in equivalence verification of
                                                                                                                            behavioral and algorithmic descriptions, where the use of symbolic,
                                                                                                                    a)      word-level operands, without the need to specify their bit-width, is
                                                                                             b)                             justified. For large systems, involving complex bit-select operations,
                                                                                                                            relational operators and memories, TEDs can be used to represent
Fig. 12. Equivalent Computations: (a) FFT-Product-Inv(FFT); (b)                                                             datapath portions of the design that can be modeled as polynomi-
     Convolution.                                                                                                           als. Equivalence checking of such complex designs typically involves
                                                                                                                            finding structurally similar points of the designs under verification.
                                                                                                                            TED data structure can be used here to raise the level of abstraction
                     C3                                      C2                  C1          C0
                                                                                                                            of large portions of designs, aiding in the identification of such simi-
                     A0.1                                   A0.2                 A0.3        A0.4   A0
                                                                                                                            lar points and in the overall verification process. In this sense TEDs
                                                                                                                            complements existing representations, such as BDDs and *BMDs, in
                         B0.1                                    B0.2          B0.3          B0.4   B0                      places where the level of abstraction can be raised.
                                                                                                                                A number of open problems remain to be researched to make TEDs
                         A3.1                                                                       A3                      a reliable data structure for high-level design representation and ver-
                                                                                                                            ification. While a simple VHDL and C interface has been already
                                B1.1                                    B1.2          B1.3          B1
                                                                                                                            provided based on the GAUT high-level synthesis system, a front-
                                                                                                                            end interface to the TED data structure should be developed for
                                       A1.1                             A1.2                        A1
                                                                                                                            designs described in Verilog and System C. The recently developed
                                                     B2.1                                           B2
                                                                                                                            dynamic variable ordering needs to be tested and integrated with the
                                                                                                                            system. Also, a robust static variable ordering needs to be investi-
                                          A2.1                                                      A2                      gated. Finally, we have recently demonstrated the potential of TEDs
                                                                                                                            in symbolic factorization and architectural synthesis, especially for
                  B3.1                                                                              B3                      DSP designs. TEDs can be used to perform top-level transforma-
                                                                                                                            tions of dataflow graphs and for architectural space exploration [60].
                                                            T1
                                                                                                                            It can also be used for DSP transform optimization by means of com-
                                                                                                                            mon subexpression elimination and factorization [61]. A prototype
     Fig. 13. TED for convolution vector C, isomorphic with IF F T                                                          software for TED-based verification and behavioral transformations,
                                                                                                                            TEDify, is available on the web [62].
  As illustrated by the above example, TEDs can be suitably aug-                                                                In summary, TEDs can play a fundamental role in providing an
mented to represent computations in the complex domain. In fact,                                                            efficient data structure for those applications that can be modeled in
,                                                                                                                                                                                                                                                                                                                                                                                      10


 sv18_o                                               sv26_o                                     sv38_o                                                                        sv33_o                       sv39_o                                                     outp         sv2_o                                                                     sv13_o


                                                                                                                                                                                   2


  inp.1                                               inp.2                                      inp.3                                                                         inp.4                        inp.5                                                      inp.6        inp.7                                                                         inp.8        inp




          sv2.1                                               sv2.2                                      sv2.3                                              sv2.4                                                   sv2.5                                     sv2.6                                       sv2.7                                           sv2.8                sv2


                                                                                                                                                                                                                                                                                                             2


                  sv33.1                                              sv33.2                                     sv33.3                                     sv33.4                                                          sv33.5                            sv33.6                                  sv33.7                                     sv33.8                        sv33


                                                                                                                           2


                           sv39.1                                              sv39.2                                     sv39.3                                      sv39.4                                                         sv39.5                sv39.6                                sv39.7                                 sv39.8                                 sv39


                                                                                                                                                                                                                                              2


 6                                  sv13.1             4                                sv13.2   2                                 sv13.3                             sv13.4                            2   2                                     sv13.5                       10       sv13.6                                 sv13.7                                     11   sv13


            6                                 2                 4                                         2                                          2                                                                 2                3                                                                         9                                          11


                    2                        sv26.1                     4                                          5                        sv26.3          5    sv26.4                                                          6                sv26.2                  3                                           sv26.5                          3                        sv26


                             2                                                    4                                       3                                                                         6                                  9                      5                     2                                                        3


                                        5                                                    4                                                                                 2        sv18                                                                                                3                                       8                                          sv18


                                                                                                                                                                      2                                                                                                                                                        3


                                                                                                                                                     sv38                                                                                                                                                                                                                      sv38




                                                                                                                                                                                               T1




                                                                      Fig. 11. Elliptic Wave Filter: TED structure obtained automatically from VHDL description.


terms of polynomials, and in particular in high level design represen-                                                                                                                                                               Kim Guldstrand Larsen, Eds. 2002, vol. 2404 of Lecture Notes in
tations and verification. We also believe that TEDs can enhance the                                                                                                                                                                  Computer Science, pp. 500–504, Springer-Verlag, Copenhagen,
effectiveness of symbolic methods offered by commercial tools, such                                                                                                                                                                  Denmark.
as Mathematica and Matlab, for the purpose of formal verification                                                                                                                                                    [15]            M. Chandrashekhar, J. P. Privitera, and J. W. Condradt, “Ap-
and synthesis of digital systems design.                                                                                                                                                                                             plication of term rewriting techniques to hardware design verifi-
      acknowledgments                                                                                                                                                                                                                cation,” in Proc. Design Automation Conf., 1987, pp. 277–282.
   The authors are indebted to Emmanuel Boutillon of LESTER,                                                                                                                                                         [16]            Z. Zhou and W. Burleson, “Equivalence Checking of Datapaths
Universit´e de Bretagne Sud, Lorient, France, for his invaluable input                                                                                                                                                               Based on Canonical Arithmetic Expressions,” in Proc. Design
regarding the application of TEDs to algorithmic verification. The                                                                                                                                                                   Automation Conference, 1995.
authors also would like to thank Pierre Bomel of LESTER, for help                                                                                                                                                    [17]            S. Vasudevan, “Automatic Verification of Arithmetic Circuits
with the GAUT system, and Namrata Shekhar of University of Utah,                                                                                                                                                                     in RTL using Term Rewriting Systems,” M.S. thesis, University
for performing BMD experiments.                                                                                                                                                                                                      of Texas, Austin, 2003.
                                                                                                                                                                                                                     [18]            J. Burch and D. Dill, Automatic Verification of Pipelined Mi-
                                                                                        References                                                                                                                                   croprocessor Control, Springer-Verlag, 1994.
                                                                                                                                                                                                                     [19]            R. Bryant, S. German, and M. Velev, “Processor Verification us-
[1]             R. E. Bryant, “Graph Based Algorithms for Boolean Function                                                                                                                                                           ing Efficient Reductions of the Logic of Uninterpreted Functions
                Manipulation,” IEEE Trans. on Computers, vol. C-35, pp. 677–                                                                                                                                                         to Propositional Logic,” ACM Trans. Computational Logic, vol.
                691, August 1986.                                                                                                                                                                                                    2, no. 1, pp. 1–41, 2001.
[2]             R. E. Bryant and Y-A. Chen, “Verification of Arithmetic Func-                                                                                                                                        [20]            M. Velev and R. Bryant, “Effective use of Boolean Satisfiability
                tions with Binary Moment Diagrams,” in Proc. Design Automa-                                                                                                                                                          Procedures in the Formal Verification of Superscalar and VLIW
                tion Conference, 1995, pp. 535–541.                                                                                                                                                                                  Microprocessors,” Journal of Symbolic Computation, vol. 35,
[3]             Y. A. Chen and R. E. Bryant, “*PHDD: An Efficient Graph Rep-                                                                                                                                                         no. 2, pp. 73–106, 2003.
                resentation for Floating Point Verification,” in Proc. ICCAD,
                                                                                                                                                                                                                     [21]            R. Bryant, S. Lahiri, and S. Seshia, “Modeling and Verifying
                1997.
                                                                                                                                                                                                                                     Systems using a Logic of Counter Arithmetic with Lambda Ex-
[4]             R. Drechsler, B. Becker, and S. Ruppertz, “The K*BMD: A
                                                                                                                                                                                                                                     pressions and Uninterpreted Functions,” CAV, 2002.
                Verification Data Structure,” IEEE Design & Test, pp. 51–59,
                1997.                                                                                                                                                                                                [22]            M. Moskewicz, C. Madigan, L. Zhang Y. Zhao, and S. Malik,
                                                                                                                                                                                                                                     “Chaff: Engineering an efficient SAT solver,” in Proc. of 38th
[5]             Priyank Kalla, An Infrastructure for RTL Validation and Ver-
                                                                                                                                                                                                                                     Design Automation Conf., June 2001, pp. 530–535.
                ification, Ph.D. thesis, University of Massachusetts Amherst,
                Dept. of ECE, Amherst, 2002.                                                                                                                                                                         [23]            E. Goldberg and Y. Novikov, “BerkMin: A Fast and Robust
[6]             M. Ciesielski, P. Kalla, Z. Zeng, and B. Rouzeyre, “Taylor Ex-                                                                                                                                                       Sat-Solver,” in Proc. Design Automation and Test in Europe,
                pansion Diagrams: A Compact Canonical Representation with                                                                                                                                                            DATE-02, 2002, pp. 142–149.
                Applications to Symbolic Verification,” in Design Automation                                                                                                                                         [24]            C.-Y. Huang and K.-T. Cheng, “Using Word-Level ATPG and
                and Test in Europe, DATE-02, 2002, pp. 285–289.                                                                                                                                                                      Modular Arithmetic Constraint Solving Techniques for Assertion
[7]             B. Taylor, Methodus Incrementorum Directa et Inversa, 1715.                                                                                                                                                          Property Checking,” IEEE Trans. CAD, vol. 20, pp. 381–391,
[8]             E. Kryrszig, Advanced Engineering Mathematics, John Wiley                                                                                                                                                            2001.
                and Sons, Inc., 1999.                                                                                                                                                                                [25]            M. Iyer, “RACE: A word-level ATPG-based Constraints Solver
[9]             H. Enderton, A mathematical Introduction to Logic, Academic                                                                                                                                                          System for Smart Random Simulation,” in Internationall Test
                Press New York, 1972.                                                                                                                                                                                                Conf., ITC-03, 2003, pp. 299–308.
[10]            T. Bultan and et. al, “Verifying Systems with Integer Con-                                                                                                                                           [26]            R. Brinkmann and R. Drechsler, “RTL-Datapath Verification
                straints and Boolean Predicates: a Composite Approach,” in                                                                                                                                                           using Integer Linear Programming,” in Proc. ASP-DAC, 2002.
                Proc. Int’l. Symp. on Software Testing and Analysis, 1998.                                                                                                                                           [27]            Z. Zeng, P. Kalla, and M. Ciesielski, “LPSAT: A unified ap-
[11]            S. Devadas, K. Keutzer, and A. Krishnakumar, “Design Verifica-                                                                                                                                                       proach to RTL satisfiability,” in Proc. DATE, March 2001, pp.
                tion and Reachability Analysis using Algebraic Manipulation,”                                                                                                                                                        398–402.
                in Proc. Intl. Conference on Computer Design, 1991.                                                                                                                                                  [28]            F. Fallah, S. Devadas, and K. Keutzer, “Functional Vector
[12]            G. Ritter, “Formal Verification of Designs with Complex Con-                                                                                                                                                         Generation for HDL Models using Linear Programming and 3-
                trol by Symbolic Simulation,” in Advanced Research Working                                                                                                                                                           Satisfiability,” in Proc. Design Automation Conference, 1998,
                Conf. on Correct Hardware Design and Verification Methods                                                                                                                                                            pp. 528–533.
                (CHARME), Springer Verlag LCNS, Ed., 1999.                                                                                                                                                           [29]            K. S. Brace, R. Rudell, and R. E. Bryant, “Efficient Implemen-
[13]            R. E. Shostak, “Deciding Combinations of Theories,” Journal                                                                                                                                                          tation of the BDD Package,” in DAC, 1990, pp. 40–45.
                of ACM, vol. 31, no. 1, pp. 1–12, 1984.                                                                                                                                                              [30]            O. Coudert and J.C. Madre, “A Unified Framework for the
[14]            Aaron Stump, Clark W. Barrett, and David L. Dill, “CVC: A                                                                                                                                                            Formal Verification of Sequential Circuits,” in Proc. ICCAD,
                Cooperating Validity Checker,” in 14th International Confer-                                                                                                                                                         1990, pp. 126–129.
                ence on Computer Aided Verification (CAV), Ed Brinksma and                                                                                                                                           [31]            H.J. Touati, H. Savoj, B. Lin, R.K. Brayton, and A. Sangiovanni-
,                                                                                                                                               11


       Vincentelli, “Implicit State Enumeration of Finite State Ma-        [59] P. Jain, “Parameterized Motion Estimation Architecture For
       chines using BDDs,” in Proc. ICCAD, 1990, pp. 130–133.                   Dynamically Varying Power and Compression Requirements,”
[32]   E. A. Emerson, “Temporal and Modal Logic,” in Formal Mod-                M.S. thesis, Dept. of Electrical and Computer Engineering, Uni-
       els and Semantics, J. van Leeuwen, Ed., vol. B of Handbook of            versity of Massachusetts, 2002.
       Theoretical Computer Science, pp. 996–1072. Elsevier Science,       [60] M. Ciesielski, S. Askar, E. Boutillon, and J. Guillot, “Behavioral
       1990.                                                                    Transformations for Hardware Synthesis and Code Optimization
[33]   K. L. McMillan, Symbolic Model Checking, Kluwer Academic                 based on Taylor Expansion Diagrams,” Dec. 2005, Patents pend-
       Publishers, 1993.                                                        ing, USSN 11/292,493 and PCT/US05/43860.
[34]   R. K. Brayton, G. D. Hachtel, A. Sangiovanni-Vencentelli,           [61] J. Guillot, E. Boutillon, D. Gomez-Prado, S. Askar, Q. Ren, and
       F. Somenzi, A. Aziz, S-T. Cheng, S. Edwards, S. Khatri,                  M. Ciesielski, “Efficient Factorization of DSP Transforms using
       Y. Kukimoto, A. Pardo, S. Qadeer, R. Ranjan, S. Sarwary,                 Taylor Expansion Diagrams,” in Design Automation and Test
       G. Shiple, S. Swamy, and T. Villa, “VIS: A System for Veri-              in Europe, DATE-06, 2006.
       fication and Synthesis,” in Computer Aided Verification, 1996.      [62] M. Ciesielski, S. Askar, D. Gomez-Prado, and Q. Ren, TED-
[35]   A. Narayan and et al., “Partitioned ROBDDs: A Compact                    ify - Software for construction and optimization of TEDs, with
       Canonical and Efficient Representation for Boolean Functions,”           application to verification and synthesis of behavioral designs,
       in Proc. ICCAD, ’96.                                                     http://tango.ecs.umass.edu/TED/Doc/html.
[36]   Y-T. Lai, M. Pedram, and S. B. Vrudhula, “FGILP: An ILP
       Solver based on Function Graphs,” in ICCAD, 93, pp. 685–689.
[37]   U. Kebschull, E. Schubert, and W. Rosentiel, “Multilevel Logic
       Synthesis based on Functional Decision Diagrams,” in EDAC,
       1992, pp. 43–47.
[38]   R. Drechsler, A. Sarabi, M. Theobald, B. Becker, and M.A.
       Perkowski,     “Efficient Representation and Manipulation of
       Switching Functions based on Order Kronecker Function De-
       cision Diagrams,” in DAC, 1994, pp. 415–419.
[39]   E. M. Clarke, K. L. McMillan, X. Zhao, M. Fujita, and J. Yang,
       “Spectral Transforms for Large Boolean Functions with Appli-
       cations to Technology Mapping,” in DAC, 93, pp. 54–60.
[40]   I. Bahar, E. A. Frohm, C. M. Gaona, G. D. Hachtel, E. Macii,
       A. Pardo, and F. Somenzi, “Algebraic Decision Diagrams and
       their Applications,” in ICCAD, Nov. 93, pp. 188–191.
[41]   S. Horeth and Drechsler, “Formal Verification of Word-Level
       Specifications,” in DATE, 1999, pp. 52–58.
[42]   Y-A. Chen and R. Bryant, “PHDD: An Efficient Graph Repre-
       sentation for Floating Point Circuit Verification,” in IEEE Int.
       Conference on Computer-Aided Design, 1997, pp. 2–7.
[43]   G. Bioul and M. Davio, “Taylor Expansion of Boolean Functions
       and of their Derivatives,” Philips Research Reports, vol. 27, no.
       1, pp. 1–6, 1972.
[44]   A. Thayse and M. Davio, “Boolean Differential Calculus and its
       Application to Switching Theory,” IEEE Trans. on Comp., vol.
       C-22, no. 4, pp. 409–420, 1973.
[45]   J. Smith and G. DeMicheli, “Polynomial Methods for Compon-
       tent Matching and Verification,” in International Conference on
       Computer-Aided Design, ICCAD’98, 1998.
[46]   J. Smith and G. DeMicheli, “Polynomial Methods for Allocating
       Complex Compontents,” in Design Automation and Test In
       Europe Conference, DATE’99, 1999.
[47]   A. Peymandoust and G. DeMicheli, “Application of Symbolic
       Computer Algebra in High-Level Data-Flow Synthesis,” IEEE
       Trans. on Computer-Aided Design, vol. 22, no. 9, pp. 1154–1165,
       Sept. 2003.
[48]   Maple, ,” http://www.maplesoft.com.
[49]   Mathematica, ,” http://www.wri.com.
[50]   The MathWorks, “Matlab,” http://www.mathworks.com.
[51]   F. Winkler, Polynomial Algorithms in Computer Algebra,
       Springer, 1996.
[52]   G. Fey, R. Drechsler, and M. Ciesielski, “Algorithms for Tay-
       lor Expansion Diagrams,” in IEEE Intl. Symposium on Multi-
       Valued Logic, ISMVL’04, 2004.
[53]   F. Brown, Boolean Reasoning, Kluwer Academic Publishers,
       1990.
[54]   D. Pradhan, S. Askar, and M. Ciesielski, “Mathematical Frame-
       work for Representing Discrete Functions as Word-level Polyno-
       mials,” in IEEE Intl. High Level Design Validation and Test
       Workshop, HLDVT-03, 2003, pp. 135–139.
[55]   LESTER, Universit´e de Bretagne Sud, “GAUT, Architectural
       Synthesis Tool,” http://lester.univ-ubs.fr:8080, 2004.
[56]   F. Somenzi, “Colorado Decision Diagram Package,” Computer
       Programme, 1997.
[57]   R. Rudell, “Dynamic Variable Ordering for Binary Decision
       Diagrams,” in Proc. Intl. Conf. on Computer-Aided Design,
       Nov. 1993, pp. 42–47.
[58]   D. Gomez-Prado, Q. Ren, S. Askar, M. Ciesielski, and E. Boutil-
       lon, “Variable Ordering for Taylor Expansion Diagrams,” in
       IEEE Intl. High Level Design Validation and Test Workshop,
       HLDVT-04, 2004, pp. 55–59.
